My scripting language should be able to process images and perform pixels transformations over their components.

1. Transformations overview

Pixel transformations should be component-wise and, for simplicity, only linear operations.

Python's numpy/scipy image processing treats the images as being 0..1-clamped values on each of their components, so
  the operations done to each component must respect that and restrict the value:

  - Clamping: if a value is greater than 1, it will become 1, while if being lower than 0, will become 0.
  - Rotating: modulo-1 is computed on the value.
              if the value is greater than 1, it will become its fractional part.
              if the value is lower than 0, it will become 1 - its fractional part (or 0 if its frac is 0).

So the operations, being linear, are component-wise or componentS-wise (multiple components may be affected at once).

Operations may scale a value, add a value, or linearly map a range of values. They also may have an optional value
  fit (restrict) type.

1.a Scalar operations:

They rely on numeric expressions. Numeric expressions are expressions involving:
  a. A literal number (e.g. 0, 1, 1.5, 0.4, -5).
  b. A variable (starting with $ symbol, like $a, $foo, $myHue).
  c. A vector variable being indexed by a numeric expression (e.g. $$a[1]).
     See the vector expressions later, and the indexing topic.
  d. Addition, subtraction, division, multiplication, inversion (unary minus) over numeric expressions.

It is indifferent whether they are applied in single or multiple color components. The exact same scalar
  value will be applied to all of them.

  Scalar assignment (each component the same value):

  h = 0.5;

  Scalar multiply each component:

  h *= 0.5;

  Scalar multiply each component, and clamp/rotate (clamp is the default when no restriction is specified):

  s *= 0.5 clamp;
  v *= 0.5 rotate;

  Scalar add to each component (clamp and rotate may apply):

  rg += 0.5 clamp;

  Scalar range-map each component (clamp and rotate may apply):

  rgb from 0.1 .. 0.2 to 0.5 .. 1., 0 rotate;

  The mapping is always strict for both bounds. Several mappings can be performed at once, like:

    a..b to c..d, e..f to g..h

  Or even a mapping have multiple parts:

    a..b..c to d..e..f

  But we should take care about these points:

    1. Mappings sources should no overlap if multiple mappings are applied.
       The first condition matching it will win.
    2. If a mapping has multiple points, we must ensure each mapping side has a strict
       orientation: either ascending or descending, since mapping sides are domains and co-domains.

1.b Vector operations:

They rely on operations returning a vector. Under the hood, vectors will be implemented with plain
  Python tuples or numpy arrays with shape (L, 1). Typically vectors relate to pixel components, so
  in practice they will not hold more than 4 elements and never less than 1. Vectors serve as a medium
  to perform component-wise operations, e.g.:

  hv = [0.2, 0.3];

  This will assign respectively each value to each component for all pixels.

  s += [0.5] rotate;

  This will behave exactly as its scalar counterpart. However:

  sv += [0.5, 0.4] clamp;

  This will behave as if it was called like:

  s += 0.5 clamp;
  v += 0.4 clamp;

The supported operations are the same. However linear mappings are a bit different:

  xyx from [0, 0.15, 0.25] .. [0.1, 0.4, 0.7] to [0, 0.15, 0.30] .. [0.15, 0.55, 0.8] clamp;

Although this could be a bit confusing to the user, but allowed. The same operations
  are allowed for these ranges with respect to the scalar alternatives.

Vector expressions are only allowed here and are like this:
  a. A literal vector, which can contain only numeric expressions separated by comma.
  b. A vector variable (starts with double dollar sign, like $$a, $$myVector).
  c. The addition, or subtraction, of two vectors if having the same size.
  d. The multiplication between a vector and a numeric expression (it is commutative).
  e. The inversion (unary minus) of a vector.
  f. The division between a vector (dividend) and a numeric expression (divider).

2. Actions

An action is a set of transformations in the former section, related to a specific color space.

By default, the colorspace is rgb, but we could choose another colorspace. An action could look like this:

    r *= 0.5;
    g += 0.5 clamp;
    b = 0.4;

If you want to change the colorspace for the action (and not use r, g, b), you can specify it:

    using xyz;
    z = 1.;
    x *= 0.6;

The `using` instruction must be the first in the action, and only one instruction of that kind is accepted.

Allowed spaces are: rgb, hsv, hed, luv, lab, xyz.

3. Conditions

A condition evaluates the pixels which will be affected by an action. They exist in an interdependent way:
  No action exists without a condition, and vice-versa.

A condition has this structure:

  on pixels: rgb == (0, 0, 0) do
    ...
  end;

This condition will operate on the RGB space, but we could specify another space by explicitly declaring it:

  on hsv pixels: ... do
    ...
  end;

The allowed pixels are the same.

A mapping involves multiples conditions with their actions. If the conditions overlap somehow, the first
  condition specified in the script will *win* the intersection, so the conditions:

  on pixels: ...cond1 do
    ...
  end;
  on hsv pixels: ...cond2 do
    ...
  end;

Will be equivalent to:

  on pixels: ...cond1 do
    ...
  end;
  on hsv pixels: ...cond2 except the pixels matched by cond1 in rgb do
    ...
  end;

The last condition will be able to specify a dummy or default expression so it can match all the
  remaining pixels. If not specified, remaining pixels will be ignored and passed as they came
  in the image. A default expression will look like this:

  on hsv pixels: remaining do
    ...
  end;

It is an error to specify a condition being the remaining pixels if it is not the last condition
  in the script. However, if using the low level API, that usage is valid although erroneous
  (your next conditions would never be evaluated).

4. Indexing.

Indexing will be the exact as Python allows for numbers:
  a. A positive index, which includes 0, is a direct index from the first (0-index) position.
  b. A negative index, which starts in -1, will count from the last position backwards.
     It will be equal to $vector_length + index.
  c. An invalid index will raise IndexError on execution.
  d. Only vector expressions can be indexed. Any numeric expression can be an index.

Indexing has top precedence, below unary operators (which always come first). This means:

  a + b[c]

Will be resolved like a + (b[c]) instead of (a + b)[c].

5. Loops